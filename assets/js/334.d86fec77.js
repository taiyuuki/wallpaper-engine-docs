(window.webpackJsonp=window.webpackJsonp||[]).push([[334],{694:function(e,t,a){"use strict";a.r(t);var r=a(26),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"shader-syntax-overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shader-syntax-overview"}},[e._v("#")]),e._v(" Shader Syntax Overview")]),e._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#preprocessor"}},[e._v("Preprocessor")])]),a("li",[a("a",{attrs:{href:"#type-casting"}},[e._v("Type Casting")])]),a("li",[a("a",{attrs:{href:"#shader-inputs-and-outputs"}},[e._v("Shader Inputs and Outputs")]),a("ul",[a("li",[a("a",{attrs:{href:"#vertex-shader"}},[e._v("Vertex Shader")])]),a("li",[a("a",{attrs:{href:"#fragment-shader"}},[e._v("Fragment Shader")])])])])])]),a("p"),e._v(" "),a("h2",{attrs:{id:"preprocessor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#preprocessor"}},[e._v("#")]),e._v(" Preprocessor")]),e._v(" "),a("p",[e._v("Wallpaper Engine uses a custom preprocessor to cull unused code and introspect a shader before compilation. The preprocessor is not a fullfledged C preprocessor and is lacking, for example, string conversion and concatenation. Conditionals should however work with boolean and logic operators, except for #elif, which isn't supported.")]),e._v(" "),a("h4",{attrs:{id:"the-following-define-directives-are-applied-based-on-context"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-following-define-directives-are-applied-based-on-context"}},[e._v("#")]),e._v(" The following define directives are applied based on context")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("GLSL")]),e._v(": Shader is being compiled as GLSL.")]),e._v(" "),a("li",[a("strong",[e._v("HLSL")]),e._v(": Shader is being compiled as HLSL.")]),e._v(" "),a("li",[a("strong",[e._v("HLSL_SM40")]),e._v(": Shader is being compiled for shader model 4.")]),e._v(" "),a("li",[a("strong",[e._v("HLSL_GS40")]),e._v(": Current renderer supports shader model 4 geometry shaders.")])]),e._v(" "),a("h4",{attrs:{id:"the-following-directives-make-it-easier-to-write-a-shader-that-supports-glsl-and-hlsl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-following-directives-make-it-easier-to-write-a-shader-that-supports-glsl-and-hlsl"}},[e._v("#")]),e._v(" The following directives make it easier to write a shader that supports GLSL and HLSL")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("texSample2D")]),e._v(" (sampler, vec2 uvs) -> vec4: Sample a simple 2D texture. First parameter is a sampler constant and the second parameter a vec2 texture coordinate.")]),e._v(" "),a("li",[a("strong",[e._v("texSample2DLod")]),e._v(" (sampler, vec2 uvs, float lod) -> vec4: Sample a simple 2D texture. First parameter is a sampler constant, the second parameter a vec2 texture coordinate and the third parameter a float to designate which mip maps get sampled.")]),e._v(" "),a("li",[a("strong",[e._v("mix")]),e._v(": Mix is the GLSL name for lerp in HLSL and accepted for both in Wallpaper Engine. So you should use "),a("strong",[e._v("mix")]),e._v(" to make the shader fully compatible.")]),e._v(" "),a("li",[a("strong",[e._v("frac")]),e._v(": frac is the HLSL name for fract in GLSL. So you should use "),a("strong",[e._v("frac")]),e._v(" to make the shader fully compatible.")]),e._v(" "),a("li",[a("strong",[e._v("saturate")]),e._v(": saturate is the HLSL name for clamp(x, 0, 1) in GLSL.")]),e._v(" "),a("li",[a("strong",[e._v("atan2")]),e._v(": atan2 is the HLSL name for atan in GLSL. So you should use "),a("strong",[e._v("atan2")]),e._v(" to make the shader fully compatible.")]),e._v(" "),a("li",[a("strong",[e._v("ddx")]),e._v(": ddx is the HLSL name for dFdx in GLSL. So you should use "),a("strong",[e._v("ddx")]),e._v(" to make the shader fully compatible.")]),e._v(" "),a("li",[a("strong",[e._v("ddy")]),e._v(": ddy is the HLSL name for dFdy in GLSL. So you should use "),a("strong",[e._v("ddy")]),e._v(" to make the shader fully compatible.")])]),e._v(" "),a("h2",{attrs:{id:"type-casting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#type-casting"}},[e._v("#")]),e._v(" Type Casting")]),e._v(" "),a("p",[e._v("Since shaders are translated into HLSL, it is recommended to use the following casting macros for construction and casting. For example, when you want to cast a 4x4 matrix into 3x3 or when you want to create a vec3 from a single float.")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("CAST2()")]),e._v(": This will call vec2(x) in GLSL and do (float2)x in HLSL.")]),e._v(" "),a("li",[a("strong",[e._v("CAST3()")]),e._v(": This will call vec3(x) in GLSL and do (float3)x in HLSL.")]),e._v(" "),a("li",[a("strong",[e._v("CAST4()")]),e._v(": This will call vec4(x) in GLSL and do (float4)x in HLSL.")]),e._v(" "),a("li",[a("strong",[e._v("CAST3X3()")]),e._v(": This will call mat3(x) in GLSL and do (float3x3)x in HLSL.")])]),e._v(" "),a("h2",{attrs:{id:"shader-inputs-and-outputs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shader-inputs-and-outputs"}},[e._v("#")]),e._v(" Shader Inputs and Outputs")]),e._v(" "),a("p",[e._v("Wallpaper Engine currently uses the old GLSL syntax based on "),a("strong",[e._v("attribute")]),e._v(", "),a("strong",[e._v("varying")]),e._v(", "),a("strong",[e._v("uniform")]),e._v(" and globals like "),a("strong",[e._v("gl_FragColor")]),e._v(".")]),e._v(" "),a("ul",[a("li",[e._v("An "),a("strong",[e._v("attribute")]),e._v(" is a hardcoded parameter that is provided by Wallpaper Engine per vertex.")]),e._v(" "),a("li",[e._v("A varying can be freely defined by you. This is what the vertex shader outputs to the pixel shader and will be linearly interpolated between adjacent vertices of a primitive.")]),e._v(" "),a("li",[e._v("Final global outputs like "),a("strong",[e._v("gl_FragColor")]),e._v(" are forwarded to the next stage to be immediately used for displaying the result of your shader.")])]),e._v(" "),a("h3",{attrs:{id:"vertex-shader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vertex-shader"}},[e._v("#")]),e._v(" Vertex Shader")]),e._v(" "),a("p",[e._v("Vertex shaders for image/text layers currently only support the attributes "),a("strong",[e._v("a_Position")]),e._v(" and "),a("strong",[e._v("a_TexCoord")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"input-attributes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-attributes"}},[e._v("#")]),e._v(" Input Attributes")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("a_Position")]),e._v(" ("),a("code",[e._v("vec3")]),e._v("): The position in object space.")]),e._v(" "),a("li",[a("strong",[e._v("a_PositionVec4")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_Normal")]),e._v(" ("),a("code",[e._v("vec3")]),e._v("): The normal in object space.")]),e._v(" "),a("li",[a("strong",[e._v("a_Tangent4")]),e._v(" ("),a("code",[e._v("vec4")]),e._v("): The tangent in object space with bitangent sign in w.")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoord")]),e._v(" ("),a("code",[e._v("vec2")]),e._v("): The basic texture coordinates.")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec3")]),e._v(" ("),a("code",[e._v("vec3")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec4")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordC1")]),e._v(" ("),a("code",[e._v("vec2")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec3C1")]),e._v(" ("),a("code",[e._v("vec3")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec4C1")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordC2")]),e._v(" ("),a("code",[e._v("vec2")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec3C2")]),e._v(" ("),a("code",[e._v("vec3")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec4C2")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordC3")]),e._v(" ("),a("code",[e._v("vec2")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec3C3")]),e._v(" ("),a("code",[e._v("vec3")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec4C3")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordC4")]),e._v(" ("),a("code",[e._v("vec2")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec3C4")]),e._v(" ("),a("code",[e._v("vec3")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec4C4")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordC5")]),e._v(" ("),a("code",[e._v("vec2")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec3C5")]),e._v(" ("),a("code",[e._v("vec3")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_TexCoordVec4C5")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")]),e._v(" "),a("li",[a("strong",[e._v("a_Color")]),e._v(" ("),a("code",[e._v("vec4")]),e._v(")")])]),e._v(" "),a("h3",{attrs:{id:"fragment-shader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fragment-shader"}},[e._v("#")]),e._v(" Fragment Shader")]),e._v(" "),a("h4",{attrs:{id:"outputs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#outputs"}},[e._v("#")]),e._v(" Outputs")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("gl_FragColor")]),e._v(" ("),a("code",[e._v("vec4")]),e._v("): The final output color for a given pixel.")])])])}),[],!1,null,null,null);t.default=o.exports}}]);